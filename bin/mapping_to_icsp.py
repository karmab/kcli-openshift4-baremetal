from jinja2 import Template
from os import path
from sys import exit
import re
import argparse
from datetime import datetime
import yaml

parser = argparse.ArgumentParser()
parser.add_argument('--mapping-file', '-m', type=str, help='Path to the mapping.txt file generated by oc-mirror.', required=True)
parser.add_argument('--output-dir', '-o', type=str, help='Path to the output directory where icsp and catalogsource yamls will be generated.')
parser.add_argument('--stdout', '-s', action='store_true', help='Outputs result to stdout instead of file.')
parser.add_argument('--mirror-config', '-c', type=str, help='Path to the oc-mirror config file, used to generate the catalogsource yaml.')
args = parser.parse_args()

if args.stdout and args.output_dir:
    print("You can only use --output-dir or --stdout")
    exit(1)

if not path.isfile(args.mapping_file):
    print("Mapping file {0} does not exist or is not a file".format(args.mapping_file))
    exit(1)

if args.mirror_config is not None and not path.isfile(args.mirror_config):
    print("Mirror config file {0} does not exist or is not a file".format(args.mirror_config))
    exit(1)

if not args.stdout:
    if args.output_dir is None:
        print("Output directory is required if not running with --stdout")
        exit(1)
    if not path.isdir(args.output_dir):
        print("Output directory {0} does not exist or is not a directory".format(args.output_dir))
        exit(1)

mapping_file = open(args.mapping_file, 'r')
lines = mapping_file.readlines()
mapping_file.close()

mirrors = []
index_images = []
for line in lines:
    # mapping.txt lines look like registry.redhat.io/openshift4/ose-csi-external-provisioner@sha256:b22ce13b97b31b2246d3427eb602f5afd2746fb9b8393f877de871dd1a8294c4=registry.example.com/openshift4/ose-csi-external-provisioner:fcb5e25e
    # With below regular expression we get two groups, source image and mirror image.
    result = re.search(r"(.+)=(.+)", line)
    source_registry_image = result.group(1)
    mirror_registry_image = result.group(2)
    # If we find some index image, we add it to this list to generate a catalogsource for it later
    if "index:v" in mirror_registry_image:
        index_images.append(mirror_registry_image)
    result = re.search(r"(.+)/", source_registry_image)
    source_registry_namespace = result.group(1)
    result = re.search(r"(.+)/", mirror_registry_image)
    mirror_registry_namespace = result.group(1)
    icsp_entry = {"source_registry_namespace": source_registry_namespace, "mirror_registry_namespace": mirror_registry_namespace}
    mirrors.append(icsp_entry)

# Remove duplicates from mirrors, we just need one entry for each registry namespace, the mirror is configured at namespace level like source registry.redhat.io/openshift4/, mirror registry.example.com/openshift4/
mirror_list = [dict(t) for t in {tuple(d.items()) for d in mirrors}]

# Sometimes we will not get index images in the mapping.txt, in those cases we can get the index images from the oc-mirror config file
if args.mirror_config is not None:
    config_file = open(args.mirror_config, 'r')
    config_data = yaml.safe_load(config_file)
    config_file.close()
    mirror_registry = config_data['storageConfig']['registry']['imageURL'].split("/")[0]
    for catalog in config_data['mirror']['operators']:
        image_namespace = catalog['catalog'].split("/")[1]
        image_name = catalog['catalog'].split("/")[2]
        index_image = mirror_registry + "/" + image_namespace + "/" + image_name
        index_images.append(index_image)

# Remove duplicates from index images
index_images = list(dict.fromkeys(index_images))


icsp_template = """
---
apiVersion: operator.openshift.io/v1alpha1
kind: ImageContentSourcePolicy
metadata:
  labels:
    operators.openshift.org/catalog: "true"
  name: operator-0
spec:
  repositoryDigestMirrors:{% for mirror in mirror_list %}
  - mirrors:
    - {{ mirror['mirror_registry_namespace'] }}
    source: {{ mirror['source_registry_namespace'] }}{% endfor %}
"""

catalogsource_template = """
{% for image in index_images %}---
apiVersion: operators.coreos.com/v1alpha1
kind: CatalogSource
metadata:
  name: {{ image.split('/')[2].split(':')[0] }}
  namespace: openshift-marketplace
spec:
  image: {{ image }}
  sourceType: grpc
{% endfor %}
"""


icsp_j2_template = Template(icsp_template)
catalogsource_j2_template = Template(catalogsource_template)


if args.stdout:
    print(icsp_j2_template.render(mirror_list=mirror_list))
    print(catalogsource_j2_template.render(index_images=index_images))
else:
    dt = datetime.now()
    timestamp = str(int(datetime.timestamp(dt)))
    catalogsource_filepath = args.output_dir + timestamp + "-catalogSource.yaml"
    icsp_filepath = args.output_dir + timestamp + "-imageContentSourcePolicy.yaml"

    # Create CatalogSource file
    with open(catalogsource_filepath, "w") as catalogsourcefile:
        catalogsourcefile.write(catalogsource_j2_template.render(index_images=index_images))
    # Create ImageContentSourcePolicy file
    with open(icsp_filepath, "w") as icspfile:
        icspfile.write(icsp_j2_template.render(mirror_list=mirror_list))

    print("CatalogSource written to {0}, ImageContentSourcePolicy written to {1}".format(catalogsource_filepath, icsp_filepath))